<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Hand → Character (Demo)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <!-- MediaPipe Tasks Vision -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>

  <style>
    body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; padding:16px; background:#0f172a; color:#e5f7f8; }
    .wrap{ max-width: 900px; margin: 0 auto; }
    h1{ margin: 8px 0 16px; font-size: clamp(20px, 4vw, 32px); color:#a7f3f7; }
    .row{ display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .card{ background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius: 14px; padding:12px; box-shadow: 0 8px 24px rgba(0,0,0,.25); }
    .videoBox{ position:relative; width:min(720px, 100%); }
    video{ width:100%; border-radius:12px; background:#000; display:block; }
    canvas{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
    .panel{ flex:1 1 280px; min-width: 280px; }
    .btn{ cursor:pointer; border-radius:10px; padding:10px 14px; border:1px solid #22d3ee; background: #0ea5a8; color:#002a2e; font-weight:700; }
    .btn.secondary{ background:transparent; color:#a7f3f7; border-color:#155e75; }
    .btn:active{ transform: translateY(1px); }
    .stat{ font-size: 14px; color:#8bdde6; }
    .bigChar{ font-size: clamp(64px, 12vw, 140px); font-weight:900; line-height:1; color:#67e8f9; text-shadow: 0 0 24px rgba(34, 211, 238, .35); }
    .mono{ font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .kv{ display:flex; justify-content:space-between; gap:8px; border-top:1px dashed rgba(255,255,255,.12); padding-top:8px; margin-top:8px; }
    .ok{ color:#86efac; } .warn{ color:#fde68a; } .err{ color:#fca5a5; }
    .hint{ font-size:13px; color:#67e8f9; opacity:.9; }
    .split{ display:flex; gap:16px; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>AIoT <span style="color:#22d3ee">Hand → Character</span> Demo</h1>

    <div class="row">
      <div class="card videoBox">
        <video id="cam" playsinline autoplay muted></video>
        <canvas id="camOverlay"></canvas>
      </div>

      <div class="card panel" style="min-height: 240px;">
        <div class="split">
          <button id="btnStart" class="btn">Enable camera</button>
          <button id="btnStop" class="btn secondary">Stop</button>
        </div>

        <div class="kv"><span>Status</span><span id="status" class="stat">Idle</span></div>
        <div class="kv"><span>Last char</span><span id="lastChar" class="stat mono">—</span></div>
        <div class="kv"><span>Confidence</span><span id="lastConf" class="stat mono">—%</span></div>
        <div class="kv"><span>Latency</span><span id="lastLat" class="stat mono">— ms</span></div>

        <div class="kv"><span>WS connection</span><span id="wsState" class="stat">disconnected</span></div>
        <div class="hint" style="margin-top:8px;">Tip: ține mâna la ~50–80 cm de cameră, lumină bună.</div>
      </div>
    </div>

    <div class="card" style="margin-top:16px; text-align:center;">
      <div id="bigChar" class="bigChar">—</div>
    </div>
  </div>

<script>
/** ========== CAMERA + MEDIAPIPE HANDS (GestureRecognizer) ========== */
let recognizer, stream, running = false, lastVideoTime = -1;

const video   = document.getElementById('cam');
const overlay = document.getElementById('camOverlay');
const ctx     = overlay.getContext('2d');

const elStatus  = document.getElementById('status');
const elLastChar= document.getElementById('lastChar');
const elLastConf= document.getElementById('lastConf');
const elLastLat = document.getElementById('lastLat');
const elBigChar = document.getElementById('bigChar');
const elWsState = document.getElementById('wsState');

const btnStart = document.getElementById('btnStart');
const btnStop  = document.getElementById('btnStop');

/* ---------- WebSocket (optional) ---------- */
const USE_WS = true;
const WS_URL = "ws://localhost:8080";
let ws = null, lastSentChar = null;

function wsConnect(){
  if (!USE_WS) return;
  try{
    ws = new WebSocket(WS_URL);
    ws.onopen  = () => { elWsState.textContent = "connected"; elWsState.className = "stat ok"; };
    ws.onclose = () => { elWsState.textContent = "disconnected"; elWsState.className = "stat"; setTimeout(()=>wsConnect(), 1500); };
    ws.onerror = () => { elWsState.textContent = "error"; elWsState.className = "stat err"; };
    ws.onmessage = (ev) => { /* server echo or control */ };
  }catch(e){
    elWsState.textContent = "ws init error"; elWsState.className = "stat err";
  }
}
wsConnect();

/* ---------- Helpers ---------- */
function setStatus(msg, cls="stat"){ elStatus.textContent = msg; elStatus.className = cls; }

const EDGES = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
function drawLandmarks(lm){
  const W = overlay.width, H = overlay.height;
  ctx.clearRect(0,0,W,H);
  ctx.lineWidth = 2; ctx.strokeStyle = "#22d3ee"; ctx.fillStyle = "#0ea5a8";
  ctx.beginPath();
  for (const [a,b] of EDGES){ ctx.moveTo(lm[a].x*W, lm[a].y*H); ctx.lineTo(lm[b].x*W, lm[b].y*H); }
  ctx.stroke();
  for (const p of lm){ ctx.beginPath(); ctx.arc(p.x*W, p.y*H, 3, 0, Math.PI*2); ctx.fill(); }
}

function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function fingerExtended(lm, tipIdx, pipIdx, margin=0.06){
  const w=lm[0], tip=lm[tipIdx], pip=lm[pipIdx];
  return dist(w, tip) > dist(w, pip) + margin;
}
function isFist(lm){
  const w = lm[0], tips=[4,8,12,16,20].map(i=>dist(w,lm[i]));
  const avg = tips.reduce((a,b)=>a+b,0)/tips.length;
  return avg < 0.22;
}
function isL(lm){
  const idx = fingerExtended(lm,8,6);
  const th  = fingerExtended(lm,4,2,0.04);
  const mid = fingerExtended(lm,12,10);
  const ring= fingerExtended(lm,16,14);
  const pin = fingerExtended(lm,20,18);
  return idx && th && !mid && !ring && !pin;
}
function isO(lm){
  const dIT = dist(lm[8], lm[4]);
  const palm= dist(lm[0], lm[9]);
  return dIT < palm*0.35; // index-tip aproape de thumb-tip
}

/* Regula simplă: L / O / E (pumn) — extensibilă */
function landmarksToChar(lm){
  if (!lm) return null;
  if (isL(lm)) return 'L';
  if (isO(lm)) return 'O';
  if (isFist(lm)) return 'E';
  return null;
}

/* ---------- Init MediaPipe ---------- */
async function loadRecognizer(){
  if (recognizer) return recognizer;
  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
  );
  recognizer = await GestureRecognizer.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath: "https://storage.googleapis.com/mediapipe-tasks/gesture_recognizer/gesture_recognizer.task"
    },
    numHands: 1,
    runningMode: "VIDEO"
  });
  return recognizer;
}

/* ---------- Camera ---------- */
async function startCamera(){
  if (stream) return;
  stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio:false });
  video.srcObject = stream;
  await video.play();
  // Canvas real size = video pixels
  overlay.width = video.videoWidth || overlay.clientWidth;
  overlay.height= video.videoHeight|| overlay.clientHeight;
  window.addEventListener('resize', () => {
    overlay.width = video.videoWidth;
    overlay.height= video.videoHeight;
  });
}
function stopCamera(){
  if (stream){ for (const t of stream.getTracks()) t.stop(); stream=null; }
  ctx.clearRect(0,0,overlay.width,overlay.height);
}

/* ---------- Debounce: trebuie 3 frame-uri consecutive la fel ---------- */
let lastChar = null, stableCount = 0;

/* ---------- Main loop ---------- */
function loop(){
  if (!running) return;
  if (video.readyState < 2){ requestAnimationFrame(loop); return; }

  if (video.currentTime !== lastVideoTime){
    const t0 = performance.now();
    const res = recognizer.recognizeForVideo(video, Date.now());
    const t1 = performance.now();

    const lm = (res.landmarks && res.landmarks[0]) ? res.landmarks[0] : null;
    if (lm) drawLandmarks(lm); else ctx.clearRect(0,0,overlay.width,overlay.height);

    // „canned” gestures (Thumb_Up etc.) – optional
    let cannedConf = 0;
    if (res.gestures && res.gestures[0] && res.gestures[0][0]){
      cannedConf = res.gestures[0][0].score || 0;
    }

    // litera din landmarks
    const ch = landmarksToChar(lm);
    const conf = ch ? Math.max(0.6, Math.min(1, cannedConf || 0.8)) : 0;

    // debouncing + UI
    if (ch === lastChar) stableCount++; else { lastChar = ch; stableCount = 1; }

    if (ch && stableCount >= 3 && conf >= 0.7){ // trimite doar dacă e stabil
      elBigChar.textContent = ch;
      elLastChar.textContent = ch;
      elLastConf.textContent = Math.round(conf*100) + '%';
      elLastLat.textContent = Math.round(t1 - t0) + ' ms';

      if (ws && ws.readyState === 1 && lastSentChar !== ch){
        ws.send(JSON.stringify({ type:'char', value: ch, confidence: conf, ts: Date.now() }));
        lastSentChar = ch;
      }
    } else if (!ch){
      elLastChar.textContent = '—';
      elLastConf.textContent = '—%';
      elLastLat.textContent = Math.round(t1 - t0) + ' ms';
    }

    lastVideoTime = video.currentTime;
  }
  requestAnimationFrame(loop);
}

/* ---------- UI handlers ---------- */
btnStart.addEventListener('click', async () => {
  try{
    setStatus('Loading model...', 'stat warn');
    await loadRecognizer();
    setStatus('Opening camera...', 'stat warn');
    await startCamera();
    running = true;
    setStatus('Running', 'stat ok');
    requestAnimationFrame(loop);
  }catch(e){
    console.error(e);
    setStatus('Error (camera or model)', 'stat err');
  }
});
btnStop.addEventListener('click', () => {
  running = false; stopCamera(); setStatus('Stopped', 'stat');
});
</script>
</body>
</html>
